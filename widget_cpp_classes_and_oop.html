<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>C++ OOP: Classes & Composition (Side-by-Side)</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css" rel="stylesheet" />
    <style>
        /* Basic Reset & Body Styles */
        body {
            font-family: 'Menlo', 'Consolas', 'DejaVu Sans Mono', monospace;
            background-color: #272822; /* Okaidia theme background */
            color: #f8f8f2; /* Okaidia theme text */
            margin: 0; /* Remove default margin */
            font-size: 16px;
            line-height: 1.6;
        }

        /* Layout Container */
        .layout-container {
            display: flex;
            height: 100vh; /* Full viewport height */
        }

        /* Tutorial Panel Styles */
        .tutorial-panel {
            flex: 3; /* Tutorial panel takes more space (e.g., 60%) */
            padding: 25px;
            overflow-y: auto; /* Allow scrolling for tutorial content */
            border-right: 2px solid #444; /* Separator line */
        }

        /* Playground Panel Styles */
        .playground-panel {
            flex: 2; /* Playground panel takes less space (e.g., 40%) */
            display: flex;
            flex-direction: column; /* Stack elements vertically if needed */
            padding: 10px; /* Some padding around the embed */
            background-color: #2c2f33; /* Slightly different background for the panel itself */
        }
        .playground-panel .jdoodle-embed-container {
            flex-grow: 1; /* Make the container for the embed take available space */
            width: 100%;
            height: 100%; /* Pym.js should handle the iframe height within this */
        }


        /* Styles for Tutorial Content (adapted from previous version) */
        .tutorial-panel h1,
        .tutorial-panel h2 {
            font-family: Arial, sans-serif;
            color: #e6db74; /* Okaidia yellow for headings */
            border-bottom: 1px solid #555;
            padding-bottom: 10px;
        }
        .tutorial-panel h1 {
            margin-top: 0;
            font-size: 1.8em; /* Slightly adjusted for panel view */
        }
        .tutorial-panel h2 {
            font-size: 1.4em;
            margin-top: 25px;
        }
        .tutorial-panel pre[class*="language-"] {
            margin-top: 15px;
            margin-bottom: 15px;
            border-radius: 0.3em;
            font-size: 0.9em; /* Slightly smaller for panel */
            border: 1px solid #444;
            overflow: auto;
            padding: 1em;
        }
        .tutorial-panel p,
        .tutorial-panel li {
            margin-bottom: 10px;
        }
        .tutorial-panel ul {
            padding-left: 20px;
        }
        .tutorial-panel code.inline-code {
            background-color: #3c3d3a;
            color: #f8f8f2;
            padding: 0.2em 0.4em;
            border-radius: 0.2em;
            font-size: 0.85em;
        }
        .tutorial-panel .explanation-box {
            background-color: #3c3d3a;
            border-left: 5px solid #ae81ff; /* Okaidia purple for emphasis */
            padding: 15px;
            margin: 20px 0;
            border-radius: 0.3em;
        }
        .tutorial-panel .explanation-box h3 {
            margin-top: 0;
            color: #a6e22e; /* Okaidia green */
            font-family: Arial, sans-serif;
            font-size: 1.1em;
        }
    </style>
</head>
<body>
    <div class="layout-container">
        <div class="tutorial-panel">
            <h1>C++ OOP: Classes & Composition</h1>

            <div class="explanation-box">
                <h3>What is Object-Oriented Programming (OOP)?</h3>
                <p>Object-Oriented Programming is a way of thinking about and organizing code. Instead of just writing sequences of commands, you design your program around "objects." These objects bundle together data and functions that operate on that data.</p>
                <p><strong>Key Ideas in OOP:</strong></p>
                <ul>
                    <li><strong>Class:</strong> A blueprint or template for creating objects. It defines what data an object will hold and what it can do.</li>
                    <li><strong>Object:</strong> An instance of a class. It's a concrete entity created from the class blueprint, with its own set of data.</li>
                    <li><strong>Encapsulation:</strong> Bundling data and methods within a class and controlling access to the data (often hiding it).</li>
                    <li><strong>Composition (covered in this tutorial):</strong> Building complex objects by combining simpler ones (a "has-a" relationship).</li>
                    <li><strong>Inheritance (later topic):</strong> Creating new classes based on existing ones (an "is-a" relationship).</li>
                    <li><strong>Polymorphism (later topic):</strong> Allowing objects of different classes to respond to the same message in different ways.</li>
                </ul>
                <p>This tutorial focuses on: <strong>Classes</strong>, <strong>Objects</strong>, <strong>Encapsulation</strong>, and simple <strong>Value-based Composition</strong>.</p>
            </div>

            <h2>Example: The `Book` Class</h2>
            <p>Let's define a class called <code class="inline-code">Book</code>. A book has attributes like a title, author, and number of pages. It can also have actions, like displaying its information.</p>

<pre class="language-cpp"><code class="language-cpp">// Code for the Book class definition
#include &lt;iostream&gt;
#include &lt;string&gt;

using std::cout;
using std::endl;
using std::string;

class Book {
private:
    string title;
    string author;
    int pages;
public:
    Book() { // Default Constructor
        title = "Unknown Title";
        author = "Unknown Author";
        pages = 0;
        cout &lt;&lt; "Default Constructor called for Book." &lt;&lt; endl;
    }
    Book(string t, string a, int p) { // Parameterized Constructor
        title = t;
        author = a;
        pages = p;
        cout &lt;&lt; "Parameterized Constructor called for Book: " &lt;&lt; title &lt;&lt; endl;
    }
    void displayInfo() const {
        cout &lt;&lt; "------------------------" &lt;&lt; endl;
        cout &lt;&lt; "Title: " &lt;&lt; title &lt;&lt; endl;
        cout &lt;&lt; "Author: " &lt;&lt; author &lt;&lt; endl;
        cout &lt;&lt; "Pages: " &lt;&lt; pages &lt;&lt; endl;
        cout &lt;&lt; "------------------------" &lt;&lt; endl;
    }
    ~Book() { // Destructor
        cout &lt;&lt; "Destructor called for Book: " &lt;&lt; title &lt;&lt; endl;
    }
};
</code></pre>
            <p><strong>Demonstrating the `Book` Class:</strong></p>
            <p>Below is a <code class="inline-code">main()</code> function that creates and uses <code class="inline-code">Book</code> objects. You can copy this into the playground to see it in action. (If you also copy the Composition example later, make sure only one <code class="inline-code">main()</code> function is active at a time).</p>
<pre class="language-cpp"><code class="language-cpp">// main function to demonstrate the Book class
// #include &lt;iostream&gt; // Already included if Book class definition is in the same file
// #include &lt;string&gt;   // Already included
// using namespace std; // Assuming Book class also uses this or std:: prefix

// (Book class definition would be above this main function if in the same file)

int main_book_demo() { // Renamed to avoid conflict if testing both examples
    cout &lt;&lt; "--- Program starting: Creating Book objects ---" &lt;&lt; endl;

    Book book1; // Calls Default Constructor
    Book book2("The Hitchhiker's Guide to the Galaxy", "Douglas Adams", 224);

    cout &lt;&lt; "\n--- Using the Book objects ---" &lt;&lt; endl;
    book1.displayInfo();
    book2.displayInfo();

    // You cannot directly access private members from outside the class:
    // book1.title = "New Title"; // This would cause a COMPILE ERROR!
    // This is because 'title' is a private member of the Book class.

    cout &lt;&lt; "\n--- Program ending: Objects will be destroyed ---" &lt;&lt; endl;
    return 0;
}
</code></pre>


            <h2>Dissecting the `Book` Class</h2>
            <ul>
                <li><strong>Class Keyword:</strong> <code class="inline-code">class Book { ... };</code> declares a new class named <code class="inline-code">Book</code>. The definition ends with a semicolon.</li>
                <li><strong>Access Specifiers:</strong>
                    <ul>
                        <li><code class="inline-code">private:</code> Members declared after this are only accessible from within the class itself. This is for <strong>data hiding</strong>.</li>
                        <li><code class="inline-code">public:</code> Members declared after this are accessible from anywhere outside the class. This forms the class's public interface.</li>
                    </ul>
                </li>
                <li><strong>Member Variables (Data Members/Attributes):</strong> Variables declared inside the class (e.g., <code class="inline-code">title</code>).</li>
                <li><strong>Member Functions (Methods):</strong> Functions declared inside the class.
                    <ul>
                        <li><strong>Constructors:</strong> Special methods for object creation and initialization.</li>
                        <li><strong>Regular Member Functions:</strong> E.g., <code class="inline-code">displayInfo() const</code>.</li>
                        <li><strong>Destructor:</strong> Special method for cleanup.</li>
                    </ul>
                </li>
                <li><strong>Creating Objects (Instantiation):</strong> E.g., <code class="inline-code">Book book1;</code>.</li>
                <li><strong>Accessing Members:</strong> Using the dot operator (<code class="inline-code">.</code>).</li>
            </ul>

            <h2>Syntax Skeletons</h2>
<pre class="language-cpp"><code class="language-cpp">/*
 * Basic Class Definition Skeleton
 */
class ClassName {
private:
    // Private member variables (data)
    // Private member functions (internal helper functions, less common for simple classes,
    // used for tasks internal to the class's operation)
public:
    // Public member variables (generally avoided to maintain encapsulation;
    // prefer providing access through public methods if needed)
    // Public member functions (the class's interface)

    /*
     * Default Constructor:
     * Initializes an object with default values.
     * Called when an object is created without arguments.
     * Example: ClassName obj;
     */
    ClassName() { /* Initialization code for member variables */ }

    /*
     * Parameterized Constructor:
     * Initializes an object with values passed as arguments.
     * Example: ClassName obj(value1, value2);
     */
    ClassName( /* parameters */ ) { /* Initialization code using parameters */ }

    /*
     * Member Function (Method):
     * Performs an action or provides information about the object.
     * 'const' can be added at the end if the function promises not to
     * modify any member variables of the object it's called on.
     */
    returnType functionName( /* parameters */ ) /* const */ { /* Function body */ }

    /*
     * Destructor:
     * Called automatically when an object is destroyed (e.g., goes out of scope
     * or is explicitly deleted if created with 'new').
     * Used for cleanup (e.g., releasing memory or other resources).
     */
    ~ClassName() { /* Cleanup code */ }
}; // End of class definition

/*
 * Object Instantiation (Creating instances of the class)
 * This is typically done in main() or another function.
 */
// ClassName objectName;          // Calls the Default Constructor
// ClassName anotherObject(arg1, arg2); // Calls a Parameterized Constructor

/*
 * Accessing Public Members
 * Use the dot (.) operator with the object's name.
 */
// objectName.publicFunctionName(); // Calling a public member function
// type someValue = objectName.publicVariable; // Accessing a public variable (if any)
</code></pre>

            <h2>Key OOP Concept: Encapsulation</h2>
            <div class="explanation-box">
                <h3>Encapsulation Explained</h3>
                <p>Encapsulation is one of the fundamental principles of OOP. It means:</p>
                <ol>
                    <li><strong>Bundling:</strong> Combining data (member variables) and the methods (member functions) that operate on that data into a single unit â€“ the class. Our <code class="inline-code">Book</code> class bundles title, author, pages, and functions like <code class="inline-code">displayInfo()</code>.</li>
                    <li><strong>Data Hiding:</strong> Restricting direct access to some of an object's components. This is typically done by making member variables <code class="inline-code">private</code>.
                        <ul>
                            <li>In the <code class="inline-code">Book</code> class, <code class="inline-code">title</code>, <code class="inline-code">author</code>, and <code class="inline-code">pages</code> are <code class="inline-code">private</code>. You can't write <code class="inline-code">book1.pages = -50;</code> from <code class="inline-code">main()</code> because this direct access is prevented.</li>
                            <li>Access to and modification of this private data is controlled through public member functions (the class's interface). For example, data is set by constructors. If we wanted to allow changing the number of pages after a book object is created, we could add a public "setter" method like <code class="inline-code">void setPages(int newPages)</code> inside the class. This method could include logic to check if <code class="inline-code">newPages</code> is a valid number (e.g., not negative) before updating the private <code class="inline-code">pages</code> member.</li>
                        </ul>
                    </li>
                </ol>
                <p><strong>Benefits of Encapsulation:</strong></p>
                <ul>
                    <li><strong>Control:</strong> The class controls how its data is accessed and potentially modified. This helps maintain the integrity of the object's state (e.g., by ensuring pages can't be set to an invalid negative number through a setter method).</li>
                    <li><strong>Security:</strong> Protects the internal state of an object from unintended or direct external modification, which could lead to errors or inconsistencies.</li>
                    <li><strong>Flexibility & Maintainability:</strong> The internal implementation details of a class (e.g., how data is stored or processed) can be changed without affecting the parts of the program that use the class, as long as the public interface (public methods) remains consistent.</li>
                    <li><strong>Simplicity:</strong> Makes the class easier to use for others. They only need to understand its public interface, not all the complex internal workings.</li>
                </ul>
            </div>

            <h2>Value-based Composition: The "Has-A" Relationship</h2>
            <div class="explanation-box">
                <h3>Building Complex Objects from Simpler Ones</h3>
                <p>Composition is a fundamental OOP concept where a class (the "whole" or "composite") is made up of, or contains, objects of other classes (the "parts"). This represents a <strong>"has-a"</strong> relationship. For example, a <code class="inline-code">Car</code> "has-an" <code class="inline-code">Engine</code>.</p>
                <p>In value-based composition (also known as composition by member object), the "part" objects are directly members of the "whole" class. Their lifetime is typically tied to the lifetime of the containing object.</p>
            </div>

            <p>Let's illustrate with an <code class="inline-code">Address</code> class and a <code class="inline-code">Person</code> class. A <code class="inline-code">Person</code> "has-an" <code class="inline-code">Address</code>.</p>
            <p>You can copy the entire code block below (including the `main()` function) into the playground to test this Composition example. Remember to only have one active `main()` function if you are combining examples.</p>
<pre class="language-cpp"><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;

using std::cout;
using std::endl;
using std::string;

// Address Class (The "Part")
class Address {
public: // Made public for easier direct access in this simple example
    string street;
    string city;
    string state;

    // Constructor for Address
    Address(string str, string c, string st) : street(str), city(c), state(st) {
        // cout &lt;&lt; "Address created: " &lt;&lt; street &lt;&lt; endl;
    }

    // Default constructor
    Address() : street("N/A"), city("N/A"), state("N/A") {
        // cout &lt;&lt; "Default Address created." &lt;&lt; endl;
    }

    void displayAddress() const {
        cout &lt;&lt; street &lt;&lt; ", " &lt;&lt; city &lt;&lt; ", " &lt;&lt; state;
    }

    ~Address() {
        // cout &lt;&lt; "Address destroyed: " &lt;&lt; street &lt;&lt; endl;
    }
};

// Person Class (The "Whole" - has an Address)
class Person {
private:
    string name;
    Address homeAddress; // Person "has-an" Address object (Composition)

public:
    Person(string n, Address addr) : name(n), homeAddress(addr) {
        cout &lt;&lt; "Person created (with existing Address): " &lt;&lt; name &lt;&lt; endl;
    }

    Person(string n, string street, string city, string state)
        : name(n), homeAddress(street, city, state) {
        cout &lt;&lt; "Person created (Address initialized inline): " &lt;&lt; name &lt;&lt; endl;
    }

    void displayPersonInfo() const {
        cout &lt;&lt; "Name: " &lt;&lt; name &lt;&lt; endl;
        cout &lt;&lt; "Home Address: ";
        homeAddress.displayAddress();
        cout &lt;&lt; endl;
    }

    ~Person() {
        cout &lt;&lt; "Person destroyed: " &lt;&lt; name &lt;&lt; endl;
    }
};

// main function to demonstrate Composition
// To run this, ensure any other main() function (like main_book_demo) is commented out or renamed.
int main() { 
    cout &lt;&lt; "--- Creating Address object first ---" &lt;&lt; endl;
    Address ad1("123 Main St", "Anytown", "CA");

    cout &lt;&lt; "\n--- Creating Person object using pre-existing Address object ---" &lt;&lt; endl;
    Person p1("Alice W.", ad1);
    p1.displayPersonInfo();

    cout &lt;&lt; "\n--- Creating Person object, initializing Address inline ---" &lt;&lt; endl;
    Person p2("Bob B.", "456 Oak Ave", "BuildCity", "NY");
    p2.displayPersonInfo();
    
    cout &lt;&lt; "\n--- Program ending ---" &lt;&lt; endl;
    return 0;
}
</code></pre>
            <p><strong>Explanation of Value-based Composition:</strong></p>
            <ul>
                <li>The <code class="inline-code">Person</code> class contains an actual <code class="inline-code">Address</code> object named <code class="inline-code">homeAddress</code> as one of its members.</li>
                <li><strong>Initialization:</strong> When a <code class="inline-code">Person</code> object is created, its <code class="inline-code">homeAddress</code> member must also be initialized. This is typically done using the member initializer list in the <code class="inline-code">Person</code> constructor.</li>
                <li><strong>Lifetime:</strong> The <code class="inline-code">homeAddress</code> object is part of the <code class="inline-code">Person</code> object. It is created when the <code class="inline-code">Person</code> object is created and destroyed when the <code class="inline-code">Person</code> object is destroyed.</li>
                <li>This is the simplest form of composition and is very common.</li>
            </ul>
            <p>Value-based composition is powerful for building complex types from simpler, well-defined parts without the immediate need to manage memory with pointers.</p>

            <h2>Summary</h2>
            <ul>
                <li><strong>Classes</strong> are blueprints for creating objects. They define attributes (data) and behaviors (methods).</li>
                <li><strong>Objects</strong> are instances of classes. Each object has its own set of data based on the class blueprint.</li>
                <li>Use <code class="inline-code">private</code> to hide internal data and implementation details (<strong>Encapsulation</strong>).</li>
                <li>Use <code class="inline-code">public</code> to define the interface through which objects are used.</li>
                <li><strong>Composition (Value-based):</strong> Classes can contain objects of other classes as members, forming a "has-a" relationship.</li>
                <li><strong>Constructors</strong> initialize objects when they are created, including member objects.</li>
                <li><strong>Destructors</strong> clean up resources when objects are destroyed, including member objects.</li>
                <li>Member functions operate on the data of the object they belong to.</li>
            </ul>
            <p>These concepts form a strong foundation in OOP. Future topics will build upon this, including Pointers and Dynamic Memory, different forms of Composition (using pointers and smart pointers), Inheritance, and Polymorphism.</p>

        </div><div class="playground-panel">
            <div class="jdoodle-embed-container">
                <div data-pym-src='https://www.jdoodle.com/embed/v1/39f9c7b2839c489a'></div>
            </div>
            <script src='https://www.jdoodle.com/assets/jdoodle-pym.min.js' type='text/javascript'></script>
        </div></div><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
</body>
</html>
